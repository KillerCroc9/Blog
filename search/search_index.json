{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Unreal Insights by Abdul","text":"<p>Hello and welcome to Unreal Insights by Abdul! I'm Abdul Muqeet, an Unreal Engine C++ developer passionate about creating tools that enhance game development experiences. Over the past year, I've immersed myself in the world of Unreal Engine, focusing on the intricate art of tool creation.</p>"},{"location":"#my-journey","title":"My Journey","text":"<p>My journey into game development initially focused on gameplay mechanics and creating immersive player experiences. However, as I expanded my horizons, I discovered the profound impact of tools in streamlining development processes and enhancing game quality. While I'm still learning and evolving, I find joy in solving challenges and sharing my experiences with others.</p>"},{"location":"#what-youll-find-here","title":"What You'll Find Here","text":"<p>In this blog, I'll be sharing insights and lessons learned from my projects in Unreal Engine. From tackling coding challenges to optimizing game performance, I aim to provide practical tips and thoughtful reflections that may resonate with fellow developers and enthusiasts.</p>"},{"location":"#join-me-on-this-journey","title":"Join Me on this Journey","text":"<p>Join me as I navigate the intricacies of Unreal Engine development. Together, we'll explore different aspects of game creation, celebrate successes, and learn from setbacks in a supportive and humble environment.</p> <p>Thank you for visiting, and I look forward to exchanging knowledge and experiences with you!</p>"},{"location":"pixelreading/","title":"How to Read Pixel Data from Images in Unreal Engine Using C++","text":"<p>In this blog post, I'll guide you through the process of reading pixel data from images in Unreal Engine using C++. This technique can be beneficial for various applications, including image processing, custom shaders, or making decisions based on image content.</p>"},{"location":"pixelreading/#prerequisites","title":"Prerequisites","text":"<p>Before diving into the code, ensure you have:</p> <ul> <li> <p>A basic understanding of Unreal Engine and C++.</p> </li> <li> <p>Unreal Engine installed and set up.</p> </li> <li> <p>A project created in Unreal Engine.</p> </li> </ul>"},{"location":"pixelreading/#step-1-include-necessary-headers","title":"Step 1: Include Necessary Headers","text":"<p>First, include the necessary headers in your <code>.cpp</code> file. These headers are essential for handling textures and image data.</p> <p>```cpp  </p> <pre><code>#include \"GetTexture.h\"\n#include &lt;ImageUtils.h&gt;\n</code></pre>"},{"location":"pixelreading/#step-2-write-the-function-to-read-pixel-data","title":"Step 2: Write the Function to Read Pixel Data","text":"<p>Here's the function to read pixel data from a UTexture2D object. This function will populate a TArray with FColor values representing each pixel''s color data, and it will also output the texture's width and height.</p> <pre><code>void AGetTexture::GetPixels(UTexture2D* Texture, int32&amp; OutWidth, int32&amp; OutHeight)\n{\n    TArray&lt;FColor&gt; PixelArray;\n\n    if (!Texture || !Texture-&gt;GetPlatformData())\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Texture is null or PlatformData is missing\"));\n        OutWidth = 0;\n        OutHeight = 0;\n        return; \n    }\n\n    // Save old texture settings\n    TextureCompressionSettings OldCompressionSettings = Texture-&gt;CompressionSettings;\n    TextureMipGenSettings OldMipGenSettings = Texture-&gt;MipGenSettings;\n    bool OldSRGB = Texture-&gt;SRGB;\n\n    // Temporarily change texture settings for pixel reading\n    Texture-&gt;CompressionSettings = TextureCompressionSettings::TC_VectorDisplacementmap;\n    Texture-&gt;MipGenSettings = TextureMipGenSettings::TMGS_NoMipmaps;\n    Texture-&gt;SRGB = false;\n    Texture-&gt;UpdateResource();\n\n    FTexture2DMipMap* MipMap = &amp;Texture-&gt;PlatformData-&gt;Mips[0];\n    const FColor* FormattedImageData = static_cast&lt;const FColor*&gt;(MipMap-&gt;BulkData.LockReadOnly());\n\n    OutWidth = MipMap-&gt;SizeX;\n    OutHeight = MipMap-&gt;SizeY;\n    PixelArray.SetNum(OutWidth * OutHeight);\n\n    for (int32 Y = 0; Y &lt; OutHeight; Y++)\n    {\n        for (int32 X = 0; X &lt; OutWidth; X++)\n        {\n            FColor PixelColor = FormattedImageData[Y * OutWidth + X];\n            PixelArray[Y * OutWidth + X] = PixelColor;\n            SpawnCubes(PixelColor, Y, X);\n        }\n    }\n\n    MipMap-&gt;BulkData.Unlock();\n\n    // Restore original texture settings\n    Texture-&gt;CompressionSettings = OldCompressionSettings;\n    Texture-&gt;MipGenSettings = OldMipGenSettings;\n    Texture-&gt;SRGB = OldSRGB;\n    Texture-&gt;UpdateResource();\n}\n</code></pre>"},{"location":"pixelreading/#explanation-of-the-function","title":"Explanation of the Function","text":"<p>Parameters:</p> <ul> <li> <p>UTexture2D* Texture: The texture from which you want to read pixel data.</p> </li> <li> <p>int32&amp; OutWidth: Output parameter for the texture's width.</p> </li> <li> <p>int32&amp; OutHeight: Output parameter for the texture's height.</p> </li> </ul>"},{"location":"pixelreading/#checking-texture-validity","title":"Checking Texture Validity","text":"<pre><code>if (!Texture || !Texture-&gt;GetPlatformData())\n{\n    UE_LOG(LogTemp, Error, TEXT(\"Texture is null or PlatformData is missing\"));\n    OutWidth = 0;\n    OutHeight = 0;\n    return; // Return empty array to indicate an error\n}\n</code></pre> <p>This section checks if the texture is valid and if it has platform data. If either is missing, it logs an error and sets the output width and height to zero.</p>"},{"location":"pixelreading/#temporarily-change-texture-settings","title":"Temporarily Change Texture Settings","text":"<pre><code>// Save old texture settings\nTextureCompressionSettings OldCompressionSettings = Texture-&gt;CompressionSettings;\nTextureMipGenSettings OldMipGenSettings = Texture-&gt;MipGenSettings;\nbool OldSRGB = Texture-&gt;SRGB;\n\n// Temporarily change texture settings for pixel reading\nTexture-&gt;CompressionSettings = TextureCompressionSettings::TC_VectorDisplacementmap;\nTexture-&gt;MipGenSettings = TextureMipGenSettings::TMGS_NoMipmaps;\nTexture-&gt;SRGB = false;\nTexture-&gt;UpdateResource();\n</code></pre> <p>Changing the texture settings is crucial for ensuring the pixel data is read correctly. Here\u2019s why each setting is important:</p>"},{"location":"pixelreading/#compression-settings","title":"Compression Settings:","text":"<p>Using TC_VectorDisplacementmap ensures the texture is not compressed in a way that would alter pixel values. Mip Generation Settings: Setting MipGenSettings to TMGS_NoMipmaps ensures you are reading the highest resolution of the texture. SRGB: Disabling SRGB ensures the color values are read linearly without gamma correction, preserving the original pixel data.</p>"},{"location":"pixelreading/#importance-of-texture-compression","title":"Importance of Texture Compression","text":"<p>Texture compression in Unreal Engine can significantly affect image quality and pixel data accuracy. When textures are compressed, color information may be altered or reduced, leading to visual artifacts or inaccuracies in applications like image processing or shader effects.</p>"},{"location":"pixelreading/#visual-comparison-compressed-vs-uncompressed-image","title":"Visual Comparison: Compressed vs. Uncompressed Image","text":""},{"location":"pixelreading/#image-compressed","title":"Image Compressed","text":""},{"location":"pixelreading/#image-uncompressed","title":"Image Uncompressed","text":"<p>The above images demonstrate the difference between an uncompressed and compressed texture. Notice how compression make pixel data completely unrecognizable.</p>"},{"location":"pixelreading/#visualizing-pixel-data","title":"Visualizing Pixel Data","text":"<p>To illustrate how texture settings impact pixel data, we can spawn cubes in Unreal Engine for each pixel color read from a texture.</p>"},{"location":"pixelreading/#locking-mipmap-data","title":"Locking MipMap Data","text":"<pre><code>FTexture2DMipMap* MipMap = &amp;Texture-&gt;PlatformData-&gt;Mips[0];\nconst FColor* FormattedImageData = static_cast&lt;const FColor*&gt;(MipMap-&gt;BulkData.LockReadOnly());\n</code></pre> <p>This part locks the mipmap data for reading. The mipmap stores different levels of texture detail, with level 0 being the highest resolution.</p>"},{"location":"pixelreading/#reading-pixel-data","title":"Reading Pixel Data","text":"<pre><code>OutWidth = MipMap-&gt;SizeX;\nOutHeight = MipMap-&gt;SizeY;\nPixelArray.SetNum(OutWidth * OutHeight);\n\nfor (int32 Y = 0; Y &lt; OutHeight; Y++)\n{\n    for (int32 X = 0; X &lt; OutWidth; X++)\n    {\n        FColor PixelColor = FormattedImageData[Y * OutWidth + X];\n        PixelArray[Y * OutWidth + X] = PixelColor;\n    }\n}\n</code></pre> <p>This loop iterates over each pixel in the texture, reading the color data and storing it in the PixelArray.</p>"},{"location":"pixelreading/#unlocking-mipmap-data","title":"Unlocking MipMap Data","text":"<pre><code>MipMap-&gt;BulkData.Unlock();\n</code></pre> <p>Finally, the function unlocks the mipmap data to ensure it''s properly released after reading.</p>"},{"location":"pixelreading/#restoring-original-texture-settings","title":"Restoring Original Texture Settings","text":"<pre><code>Texture-&gt;CompressionSettings = OldCompressionSettings;\nTexture-&gt;MipGenSettings = OldMipGenSettings;\nTexture-&gt;SRGB = OldSRGB;\nTexture-&gt;UpdateResource();\n</code></pre> <p>Restoring the original texture settings ensures the texture is returned to its initial state after the pixel data is read.</p> <p>By following these steps, you can effectively read pixel data from images in Unreal Engine using C++. This functionality opens up various possibilities for image manipulation and analysis within your Unreal Engine projects. </p>"}]}